diff --git a/tools/geometry.py b/tools/geometry.py
index fa090571fd208bd8c2d01e057a4469119645bf3c..d59c5fe109a221ffb9131f17dc9b667e2f0de10b 100644
--- a/tools/geometry.py
+++ b/tools/geometry.py
@@ -193,62 +193,62 @@ class CubeShape(BaseShape):
 
 class DropShape(BaseShape):
     def initial_position(self):
         R = float(self.constants['drop_r'])
         theta = np.arccos(2 * np.random.rand() - 1)
         phi = np.random.uniform(-np.pi, np.pi)
         s = R * np.random.rand() ** (1/3)
         x = s * np.sin(theta) * np.cos(phi)
         y = s * np.sin(theta) * np.sin(phi)
         z = s * np.cos(theta)
         return np.array([x, y, z])
 
     def io_check(self, point, stick_status):
         R = float(self.constants["drop_r"])
         if point[2] < 0:
             return IOStatus.OUTSIDE
         norm = np.linalg.norm(point)
         if norm < R:
             return IOStatus.INSIDE
         if np.isclose(norm, R, atol=1e-9):
             return IOStatus.TEMP_ON_SURFACE
         return IOStatus.OUTSIDE
 
 class SpotShape(BaseShape):
     def initial_position(self):
-        radius = float(self.constants['spot_r'])  # ✅ spot用
-        spot_angle_rad = np.deg2rad(float(self.constants['spot_angle']))
+        """Return a random point uniformly distributed inside a spherical cap."""
+        radius = float(self.constants['spot_r'])
+        angle_rad = np.deg2rad(float(self.constants['spot_angle']))
+        cos_min = np.cos(angle_rad)
+
         while True:
-            theta = np.random.uniform(0, spot_angle_rad)
-            phi = np.random.uniform(-np.pi, np.pi)
-            r = radius * (np.random.rand() ** (1/3))
-            x = r * np.sin(theta) * np.cos(phi)
-            y = r * np.sin(theta) * np.sin(phi)
-            z = r * np.cos(theta)
-            if z >= radius * np.cos(spot_angle_rad):
-                break
-        return np.array([x, y, z])
+            vec = np.random.normal(size=3)
+            vec /= np.linalg.norm(vec) + 1e-12
+            r = radius * (np.random.rand() ** (1 / 3))
+            point = vec * r
+            if point[2] >= radius * cos_min:
+                return point
 
     def io_check(self, base_point, temp_point=None):
         R = float(self.constants["radius"])
         if temp_point is None:
             return IOStatus.OUTSIDE
         norm = np.linalg.norm(temp_point)
         if norm < R:
             return IOStatus.INSIDE
         if np.isclose(norm, R, atol=1e-9):
             return IOStatus.TEMP_ON_SURFACE
         return IOStatus.OUTSIDE
 
 class CerosShape(BaseShape):
     def initial_position(self):
         x_min, x_max, y_min, y_max, z_min, z_max = self.get_limits()
         return np.random.uniform([x_min, y_min, z_min], [x_max, y_max, z_max])
 
     def io_check(self, point):
         # cerosもcubeと同じ判定
         x_min, x_max, y_min, y_max, z_min, z_max = self.get_limits()
         eps = 1e-9
         inside = (x_min < point[0] < x_max) and (y_min < point[1] < y_max) and (z_min < point[2] < z_max)
         if inside:
             return IOStatus.INSIDE, None
         on_edge = (
