diff --git a/simcore/engine.py b/simcore/engine.py
index 23e50500d3e3354806498b5ac3a74318956f646b..8453eba50ed6b825c3ecc12e57f5ec7e1df78a99 100644
--- a/simcore/engine.py
+++ b/simcore/engine.py
@@ -109,52 +109,58 @@ class SimulationEngine:
                 elif status == IOStatus.ON_POLYGON:
                     pass  # 上記drop内で処理済
                 elif status in [IOStatus.REFLECT]:
                     vec *= -1
                 elif status in [IOStatus.STICK]:
                     stick_status = int(hz)
                 elif status in [IOStatus.BORDER, IOStatus.BOTTOM_OUT, IOStatus.SPOT_EDGE_OUT]:
                     pass  # その場に留まる
                 else:
                     print(f"[WARNING] Unexpected status: {status}")
 
                 self.trajectory[j, i] = pos
                 self.vectors[j, i] = vec
 
         print("[DEBUG] 初期位置数:", len(self.initial_position))
         print("[DEBUG] 精子数:", self.number_of_sperm)
         self.trajectories = self.trajectory  # 外部用
 
         # 保存処理
         if save_flag:
             os.makedirs(result_dir, exist_ok=True)
             np.save(os.path.join(result_dir, f"{save_name}.npy"), self.trajectory)
 
         # 描画処理
         display_mode = self.constants.get("display_mode", "2D")
-        if display_mode == "2D":
+        if isinstance(display_mode, (list, tuple)):
+            display_mode = display_mode[0]
+        display_mode = str(display_mode).strip().lower()
+
+        if display_mode == "2d":
             plot_2d_trajectories(self.trajectory, self.constants)
+        elif display_mode == "3d":
+            plot_3d_trajectories(self.trajectory, self.constants)
         elif display_mode == "movie":
             draw_3d_movies(self.trajectory, self.constants)
         else:
             print(f"[WARNING] 未対応の表示モード: {display_mode}")
 
     def _select_mode(self):
         if self.shape == "cube":
             return CubeMode(self.constants)
         elif self.shape == "drop":
             return DropMode(self.constants)
         elif self.shape == "spot":
             return SpotMode(self.constants)
         elif self.shape == "reflection":
             return ReflectionMode(self.constants)
         else:
             raise ValueError(f"[ERROR] Unknown shape mode: {self.shape}")
 
     
     def simulate(self, on_progress=None):
         initial_position = self.constants['initial_position']
         trajectories = np.full((self.number_of_sperm, self.number_of_steps, 3), np.nan)
         vectors = np.zeros((self.number_of_sperm, self.number_of_steps, 3))
 
         for j in range(self.number_of_sperm):
             position = self._generate_initial_position()
